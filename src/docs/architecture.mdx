---
title: Architecture
---

This page provides a brief overview of the Peregrine API to discuss terms and
concepts before diving a bit deeper into the implementation details.

## Overview

Peregrine has a library for web and a library for each native platform. The
native library provides the [Web Frame](#web-frames), which encapsulates the
web view. Developers create [Remote Interfaces](#remote-interfaces) and attach
them to the Web Frame for web\<-\>native communication. Remote Interfaces
contain [functions](#functions) for request/response-style communication and
[observables](#observables) for pub/sub-style communication. The implementation
of this communication between web and native is often called the _bridge_.

### Web Frames

Web Frames are instances of the `WebFrame` class in {platform}. Essentially,
they are meant to represent a single, supercharged web view. Web Frames are set
up specifically for the web content they display, e.g. web view configuration
and native access are tailored. Many hybrid developers may only use one Web
Frame for their entire app--and that's fine! Others may want to have a mix of
web and native views.

Web Frames encapsulate the web view itself, [path handlers](#path-handlers) for
implementing responses to web view requests, and a [Remote
Interface](#remote-interfaces) for implementing native functionality.

### Remote Interfaces

Remote Interfaces contain [functions](#functions) and
[observables](#observables) in {platform} or web that are used by the other
side of the bridge. Functions are used to invoke something, e.g. run a native
API, send back data, be notified of a particular lifecycle event, etc.
Observables are used to receive a stream of notifications, e.g. network status,
geofencing updates, keyboard events, etc.

The functions and observables that comprise a remote interface are provided
when configuring the Web Frame. Each function and observable must have a unique
string key for the client's usage.

Observables must end in a dollar sign (`$`) to denote a reactive property, as
popularized by [Cycle.js](https://cycle.js.org). This isn't merely
convention--the dollar sign is how the client knows it's an observable, not a
function.

Functions and observables may also contain any number of periods for
namespacing. In the following example, a period is used in each key to organize
`openBrowser()` and `closeBrowser()` functions under a single `Browser`
namespace.

<T ios>

```swift
func openBrowser(call: Call) { ... }

func closeBrowser(call: Call) { ... }

let configuration = WebFrame.Configuration(
    baseURL: ...
    functions: [
        "Browser.open": openBrowser,
        "Browser.close": closeBrowser,
    ],
    observables: [:]
)
```

</T>
<T android>

```kotlin
fun openBrowser(call: Call) { ... }

fun closeBrowser(call: Call) { ... }

val configuration = WebFrame.Configuration(
    baseUrl: ...
    functions = mapOf(
        "Browser.open" to ::openBrowser,
        "Browser.close" to ::closeBrowser,
    ),
    observables = emptyMap(),
)
```

</T>

Then, we use these remote functions on web by invoking them as if they were
normal JavaScript functions.

```typescript
const { Browser } = client // an instance of ProxyClient

await Browser.open('https://peregrinejs.com')
await Browser.close()
```

#### Functions

Remote interface functions are regular functions in <T ios>Swift</T><T
android>Kotlin</T> and JavaScript. Since functions in each of these languages
have first-class support, we can simply pass them as references when building
the remote interface.

Remote functions should accept a single parameter: `call`. An instance of the
`Call` class represents a single function call over the bridge. It is used to
retrieve request data and send a response.

For example, the following function responds with the same data that the client
sent.

<T ios>

```swift
func echo(call: Call) {
    call.respond(with: call.request.data)
}
```

</T>
<T android>

```kotlin
fun echo(call: Call) {
    call.respond(call.request.data)
}
```

</T>

#### Observables

Remote interface observables are reactive streams of `Event` instances. They
are implemented with <T ios>[Combine
Framework](https://developer.apple.com/documentation/combine), the reactive
programming library that powers SwiftUI</T><T android>[Asynchronous
Flows](https://kotlinlang.org/docs/flow.html), a powerful coroutine-based
reactive programming library built by the Kotlin team</T>.

In the following example, calling the `hide()` method will publish a new event
to the subscriber within Peregrine for {platform} and then sent over the bridge
to the web layer.

<T ios>

```swift
class SplashScreen: ObservableObject {
    @Published var visible: Event?

    func hide() {
        visible = Event(false)
    }
}

let splashScreen = SplashScreen()

let configuration = WebFrame.Configuration(
    baseURL: ...
    functions: ...
    observables: [
        "SplashScreen.visible$": splashScreen.$visible.eraseToAnyPublisher()
    ]
)
```

</T>
<T android>

```kotlin
class SplashScreen(val scope: CoroutineScope) {
    val visible = MutableSharedFlow<Event>()

    fun hide() {
        scope.launch { visible.emit(Event(false)) }
    }
}

val splashScreen = SplashScreen(scope = lifecycleScope)

val configuration = WebFrame.Configuration(
    baseUrl = ...
    functions = ...
    observables = mapOf(
        "SplashScreen.visible$": splashScreen.visible.asSharedFlow()
    ),
)
```

</T>

The Peregrine web client exposes these events as async generators, which can be
iterated over by using
[for-await...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)
loops.

```typescript
const { SplashScreen } = client

for await (const visible of SplashScreen.visible$) {
  if (!visible) {
    console.log('Splash screen is now hidden.')
  }
}
```

For a more declarative API in reactive apps, it is easy to convert async
generators to [RxJS](https://rxjs.dev) observables. This can be an idiomatic
choice for simulating a single pipeline of asynchronous events across
platforms.

```typescript
import { filter, from } from 'rxjs'

const visible$ = from(SplashScreen.visible$)

visible$.pipe(filter(v => !v)).subscribe(() => {
  console.log('Splash screen is now hidden.')
})
```

### Path Handlers

Developers attach path handlers to the Web Frame for handling web view
requests. Path handlers are usually used for providing assets and resources to
the web view.

In the following example, the `/photos/` path is being registered and linked to
a directory on the native device. When web view requests come in, Peregrine
will handle them according to the given asset loader. Think of it like a static
file server.

<T ios>

```swift
let documentsURL = try FileManager.default.url(
    for: .documentDirectory,
    in: .userDomainMask,
    appropriateFor: nil,
    create: true
)

let photosURL = documentsURL.appendingPathComponent("photos")

let configuration = WebFrame.Configuration(
    baseURL: ...
    functions: ...
    observables: ...
    pathHandlers: [
        "/photos/": InternalStoragePathHandler(directory: photosURL)
    ]
)
```

</T>
<T android>

```kotlin
val photosDir = context.filesDir.resolve("photos")
photosDir.mkdirs()

val configuration = WebFrame.Configuration(
    baseUrl = ...
    functions = ...
    observables = ...
    pathHandlers = mapOf(
        "/photos/" to WebViewAssetLoader.InternalStoragePathHandler(
            context,
            photosDir
        )
    ),
)
```

</T>

## Implementation

<Callout type="construction" title="Under Construction" />
