import Callout from '@src/components/Callout'
import Content from '@src/components/docs/Content'
import Layout from '@src/components/docs/Layout'
import Platform from '@src/components/docs/Platform'

export const meta = { title: 'Architecture' }

# Architecture

This page provides a brief overview of the Peregrine API to discuss terms and
concepts before diving a bit deeper into the implementation details.

## Overview

Peregrine has a library for web and a library for each native platform. The
native library provides the [Web Frame](#web-frames), which encapsulates the
web view. Developers create [Remote Interfaces](#remote-interfaces) and attach
them to the Web Frame for web\<-\>native communication. Remote Interfaces
contain [functions](#functions) for request/response-style communication and
[observables](#observables) for pub/sub-style communication. The implementation
of this communication between web and native is often called the _bridge_.

### Web Frames

Web Frames are instances of the `WebFrame` class in <Platform />. Essentially,
they are meant to represent a single, supercharged web view. Web Frames are set
up specifically for the web content they display, e.g. web view configuration
and native access are tailored. Many hybrid developers may only use one Web
Frame for their entire app--and that's fine! Others may want to have a mix of
web and native views.

Web Frames encapsulate the web view itself, [path handlers](#path-handlers) for
implementing responses to web view requests, and a [Remote
Interface](#remote-interfaces) for implementing native functionality.

### Remote Interfaces

Remote Interfaces are instances of the `RemoteInterface` class in <Platform />
or web. They represent the API of one side of the bridge. Remote Interfaces
contain _endpoints_, which are either [functions](#functions) or
[observables](#observables). Functions are used to invoke something, e.g. run a
native API, send back data, be notified of a particular lifecycle event, etc.
Observables are used to receive a stream of notifications, e.g. network status,
geofencing updates, keyboard events, etc.

To construct a remote interface, instantiate `RemoteInterface` with `functions`
and `observables`. Each endpoint must have a string key which is what the other
side of the bridge will use to access it.

Observables must end in a dollar sign to denote a reactive property, as
popularized by [Cycle.js](https://cycle.js.org). This isn't merely
convention--the dollar sign is how the client knows it's an observable, not a
function.

Endpoints can also contain periods for namespacing. In the following example, a
period is used in each key to organize `show()` and `hide()` functions and a
`visible$` observable under a single `SplashScreen` namespace.

<Content platform="iOS">

```swift
let splashScreen = SplashScreen()

let remoteInterface = RemoteInterface(
    functions: [
        "SplashScreen.show": splashScreen.show,
        "SplashScreen.hide": splashScreen.hide,
    ],
    observables: [
        "SplashScreen.visible$": splashScreen.$visible.eraseToAnyPublisher(),
    ],
)
```

</Content>
<Content platform="Android">

```kotlin
val splashScreen = SplashScreen()

val remoteInterface = RemoteInterface(
    functions = mapOf(
        "SplashScreen.show" to ::splashScreen.show,
        "SplashScreen.hide" to ::splashScreen.hide,
    ),
    observables = mapOf(
        "SplashScreen.visible$" to splashScreen.asSharedFlow(),
    ),
)
```

</Content>

#### Functions

Remote interface functions are regular functions in Swift, Kotlin, and
JavaScript. Since functions in each of these languages have first-class
support, we can simply pass them as references to the remote interface(s).

Remote functions should accept a single parameter: `call`. An instance of the
`Call` class represents a single function call over the bridge. It is used to
retrieve request data and send a response.

For example, the following function responds with the same data that the client
sent.

<Content platform="iOS">

```swift
func echo(call: Call) {
    call.respond(call.request.data)
}
```

</Content>
<Content platform="Android">

```kotlin
fun echo(call: Call) {
    call.respond(call.request.data)
}
```

</Content>

#### Observables

Remote interface observables are reactive streams of `Event` instances. They
are implemented with <Content platform="iOS">[Combine
Framework](https://developer.apple.com/documentation/combine) in
iOS</Content><Content platform="Android">[Asynchronous
Flows](https://kotlinlang.org/docs/flow.html) in Android</Content> and
[RxJS](https://rxjs.dev) in web.

In the following example, calling the `show()` method will emit `true` to
subscribers in the web layer.

<Content platform="iOS">

```swift
class SplashScreen {
    @Published var visible: Event?

    ...

    func show() {
        self.visible = true
    }
}
```

</Content>
<Content platform="Android">

```kotlin
class SplashScreen(val scope: CoroutineScope) {
    val visible = MutableSharedFlow<Event>()

    ...

    fun show() {
        scope.launch { visible.emit(Event(true)) }
    }
}

```

</Content>

### Path Handlers

Developers attach path handlers to the Web Frame for handling web view
requests. Path handlers are usually used for providing assets and resources to
the web view.

In the following example, the `/photos` path is being registered and linked to
a directory on the native device. When web view requests come in, Peregrine
will handle them according to the given asset loader. Think of it like a static
file server.

<Content platform="iOS">

```swift
let documentsURL = try FileManager.default.url(
    for: .documentDirectory,
    in: .userDomainMask,
    appropriateFor: nil,
    create: true
)

let photosURL = documentsURL.appendingPathComponent("photos")

let configuration = WebFrame.Configuration(
    ...
    pathHandlers = [
        "/photos/": InternalStoragePathHandler(directory: photosURL)
    ]
)

```

</Content>
<Content platform="Android">

```kotlin
val photosDir = context.filesDir.resolve("photos")
photosDir.mkdirs()

val configuration = WebFrame.Configuration(
    ...
    pathHandlers = mapOf(
        "/photos/" to WebViewAssetLoader.InternalStoragePathHandler(
            context,
            photosDir
        )
    ),
)
```

</Content>

## Implementation

The implementation differs per platform.

export default ({ children }) => <Layout meta={meta}>{children}</Layout>
